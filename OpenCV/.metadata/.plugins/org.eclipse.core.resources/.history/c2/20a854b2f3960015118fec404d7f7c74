import java.util.List;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Vector;

import org.opencv.calib3d.Calib3d;
import org.opencv.core.Core;
import org.opencv.core.Core.MinMaxLocResult;
import org.opencv.core.CvType;
import org.opencv.core.DMatch;
import org.opencv.core.KeyPoint;
import org.opencv.core.Mat;
import org.opencv.core.MatOfByte;
import org.opencv.core.MatOfDMatch;
import org.opencv.core.MatOfKeyPoint;
import org.opencv.core.MatOfPoint2f;
import org.opencv.core.Point;
import org.opencv.core.Scalar;
import org.opencv.features2d.DescriptorExtractor;
import org.opencv.features2d.DescriptorMatcher;
import org.opencv.features2d.FeatureDetector;
import org.opencv.features2d.Features2d;
import org.opencv.imgproc.Imgproc;
import org.opencv.imgcodecs.*;

class FindQR {
	public HashMap<String, Double> run(String inFile, String templateFile, int match_method) {
	    System.out.println("\nRunning Features2D...\n");
	    	    
	    Mat img = Imgcodecs.imread(getClass().getResource(inFile).getPath());
	    Mat templ = Imgcodecs.imread(getClass().getResource(templateFile).getPath());	  
	    	    
	    if(img.empty() || templ.empty())
	    {
	        System.out.println("Can't read one of the images\n");
	        return null;
	    }
	    
	    FeatureDetector detector = FeatureDetector.create(FeatureDetector.ORB);
	    DescriptorExtractor descriptor = DescriptorExtractor.create(DescriptorExtractor.ORB);
	    DescriptorMatcher matcher = DescriptorMatcher.create(DescriptorMatcher.BRUTEFORCE);

	    //set up img (scene)
	    Mat descriptors1 = new Mat();
	    MatOfKeyPoint keypoints1 = new MatOfKeyPoint();
	    //calculate descriptor for img
	    detector.detect(img, keypoints1);
	    descriptor.compute(img, keypoints1, descriptors1);

	    //set up templ (template)
	    Mat descriptors2 = new Mat();
	    MatOfKeyPoint keypoints2 = new MatOfKeyPoint();
	    //calculate descriptor for templ
	    detector.detect(templ, keypoints2);
	    descriptor.compute(templ, keypoints2, descriptors2);

	    //match 2 images' descriptors
	    MatOfDMatch matches = new MatOfDMatch();
	    matcher.match(descriptors1, descriptors2, matches);
	    
	    //calculate max and min distances between keypoints
	    double max_dist = 0;
	    double min_dist = 2000;

	    List<DMatch> matchesList = matches.toList();
	    for(int i=0;i<descriptors1.rows();i++)
	    {
	        double dist = matchesList.get(i).distance;
	        if (dist<min_dist && dist > 0.0) min_dist = dist;
	        if (dist>max_dist) max_dist = dist;
	    }
	    
	    //set up good matches, add matches if close enough
	    LinkedList<DMatch> good_matches = new LinkedList<DMatch>();
	    MatOfDMatch gm = new MatOfDMatch();
	    for (int i=0;i<descriptors2.rows();i++)
	    {
	    	System.out.println(matchesList.get(i).distance);
	    	System.out.println(matchesList.get(i).distance<3*min_dist);
	        if(matchesList.get(i).distance<3*min_dist)
	        {
	            good_matches.addLast(matchesList.get(i));
	        }
	    }
	    gm.fromList(good_matches);
	    
	    System.out.println(good_matches);

	    //put keypoints mats into lists
	    List<KeyPoint> keypoints1_List = keypoints1.toList();
	    List<KeyPoint> keypoints2_List = keypoints2.toList();

	    //put keypoints into point2f mats so calib3d can use them to find homography
	    LinkedList<Point> objList = new LinkedList<Point>();
	    LinkedList<Point> sceneList = new LinkedList<Point>();
	    for(int i=0;i<good_matches.size();i++)
	    {
	        objList.addLast(keypoints2_List.get(good_matches.get(i).queryIdx).pt);
	        sceneList.addLast(keypoints1_List.get(good_matches.get(i).trainIdx).pt);
	    }
	    MatOfPoint2f obj = new MatOfPoint2f();
	    MatOfPoint2f scene = new MatOfPoint2f();
	    obj.fromList(objList);
	    scene.fromList(sceneList);

	    //output image
	    Mat outputImg = new Mat();
	    MatOfByte drawnMatches = new MatOfByte();
	    Features2d.drawMatches(img, keypoints1, templ, keypoints2, gm, outputImg, Scalar.all(-1), Scalar.all(-1), drawnMatches,Features2d.NOT_DRAW_SINGLE_POINTS);
	    System.out.println("105");
	    boolean saved = Imgcodecs.imwrite("testwithfeatures2dAttempt2.png", outputImg);
	    System.out.println(saved);
	    
	    System.out.println(obj);
	    System.out.println(scene);
	    System.out.println(Calib3d.RANSAC);
	    
	    //run homography on object and scene points
	    Mat H = Calib3d.findHomography(obj, scene, Calib3d.RANSAC, 5);
	    Mat tmp_corners = new Mat(4,1,CvType.CV_32FC2);
	    Mat scene_corners = new Mat(4,1,CvType.CV_32FC2);

	    //get corners from object
	    tmp_corners.put(0, 0, new double[] {0,0});
	    tmp_corners.put(1, 0, new double[] {templ.cols(),0});
	    tmp_corners.put(2, 0, new double[] {templ.cols(),templ.rows()});
	    tmp_corners.put(3, 0, new double[] {0,templ.rows()});

	    Core.perspectiveTransform(tmp_corners,scene_corners, H);
	    
	    System.out.println("119");
	    System.out.println(scene_corners);


//	    Core.line(outputImg, new Point(scene_corners.get(0,0)), new Point(scene_corners.get(1,0)), new Scalar(0, 255, 0),4);
//	    Core.line(outputImg, new Point(scene_corners.get(1,0)), new Point(scene_corners.get(2,0)), new Scalar(0, 255, 0),4);
//	    Core.line(outputImg, new Point(scene_corners.get(2,0)), new Point(scene_corners.get(3,0)), new Scalar(0, 255, 0),4);
//	    Core.line(outputImg, new Point(scene_corners.get(3,0)), new Point(scene_corners.get(0,0)), new Scalar(0, 255, 0),4);
	    
//	    MatOfKeyPoint keyPointsImg = new MatOfKeyPoint();
//	    MatOfKeyPoint keyPointsTempl = new MatOfKeyPoint();
//	    FeatureDetector myFeatureDetector = FeatureDetector.create(FeatureDetector.FAST);
//	    myFeatureDetector.detect(img,keyPointsImg);
//	    myFeatureDetector.detect(templ, keyPointsTempl);
//	    Mat result = new Mat();
//	    
//	    Features2d.drawMatches(img, keyPointsImg, templ, keyPointsTempl, matches, result);
	    
	    
//	    Mat mGray = img;
//	    Mat mObject = templ;
//	    
//	    Mat mView = mGray.clone();
//	    FeatureDetector myFeatureDetector=FeatureDetector.create(FeatureDetector.FAST);
//	    MatOfKeyPoint keypoints=new MatOfKeyPoint();
//	    myFeatureDetector.detect(mGray,keypoints);
//	    MatOfKeyPoint objectkeypoints=new MatOfKeyPoint();
//	    myFeatureDetector.detect(mObject,objectkeypoints);
//	    DescriptorExtractor Extractor=DescriptorExtractor.create(DescriptorExtractor.ORB);
//	    Mat sourceDescriptors=new Mat();
//	    Mat objectDescriptors=new Mat();
//	    Extractor.compute(mGray,keypoints,sourceDescriptors);
//	    Extractor.compute(mGray,objectkeypoints,objectDescriptors);
//	    DescriptorMatcher matcher=DescriptorMatcher.create(DescriptorMatcher.BRUTEFORCE_HAMMING);
//	    MatOfDMatch matches=new MatOfDMatch();
//	    matcher.match(sourceDescriptors,objectDescriptors,matches);
//	    Features2d.drawMatches(mGray,keypoints,mObject,objectkeypoints,matches,mView);
//	    Imgproc.resize(mView,mView,mGray.size());
//	    boolean saved = Imgcodecs.imwrite("testwithfeatures2d.png", mView);
	
	    //coordsResult stores the dimensions of the large image (largeWidth, largeHeight)
	    //as well as the location of the middle of the QR code (xCoord, yCoord)
	    HashMap<String, Double> coordsResult = new HashMap<String, Double>();
	    coordsResult.put("largeWidth", (double) img.cols());
	    coordsResult.put("largeHeight", (double) img.rows());
	    coordsResult.put("xCoord", -1.0);
	    coordsResult.put("yCoord", -1.0);
	    
	    return coordsResult;	    
	}
}