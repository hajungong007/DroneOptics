Algorithm for Drone Movement


5 components:
-start call that takes image, processes it, determines zoom ratio (1/x) and meter to pixel ratio and then calls the algorithm for movement

-recursive algorithm that splits the image into quarters and moves the drone accordingly
to a position directly over the QR code with altitude  —> (1/x)altitude

-helper method that finds which quadrant the QR code is in

-landing method (once has reached a certain threshold say ~5 feet)


start() {
	altitude = getDroneAlt();
	// take picture with straight down view from drone, pass to program to locate code
	HashMap<String, Double> map = getMap();
	// these are in PIXEL dimensions!!
	imageWidthinPX = map.get(width);
	imageHeightinPX = map.get(height);
	QRx = map.get x-coord;
	QRy = map.get y-coord;

	// zoom ratio example ½ would lower drone to half its altitude 
	set zoomRatio = 
		if (altitude >50) = 1/2;
		else (altitude>25) = 2/3;
		else (altitude >10) = 3/4;
		else altitude <10) = 7/8;
	// will want to vary this depending on altitude, yet to determine, we can start
	// with this way and tune these ratios as we experiment

	// ** use altitude and angle to get ratio **
	imageWidthinMeters =(altitude in meters)*(tan(angle in radians))*2
	meterToPixelRatio = imgWidthinMeters / imageWinPX;
	// example calculation using image 
	// have 12 mpx image, say 3:2 ratio, 4243 x 2829
	// altitude ~50 meters, angle 38 degrees ~.66 radians gives half the width of 
	// the image —> 50*tan(.66) = 39.06427
	// 39.06427*2 = 78.1285 meters (width of the image in meters on ground)
	// ratio = 78.1285 / 4243 —> 0.018414
	

	moveDrone(altitude, zoomMultiple, meterToPixelRatio, imageWPX, imagegHPX, QRx, 	QRy);
}

// recursive function to move the drone
moveDrone(Double alt, Double ratio, Double imgW, Double imgH, Double QRx, Double QRy) {
	String quad = findQuadrant(QRx, QRy, imgW, imgH);
	
	
	// calculate amount will need to move drone left/right or up/down based
	// on location (which quadrant), moveX and moveY are in meters!! 
	
	if (upper right or lower right) // on right side
		moveX = (mtoPxRatio) * (QRx -imgW/2);
	else // on left side
		moveX = (mtoPxRatio) * (imgW/2 - QRx);
		
	if (lower left or lower right) // on south side
		moveY = (mtoPxRatio) * (QRy - imgH/2);
	else // on north side
		moveY = (mtoPxRatio) * (imgH/2 - QRy);
	
	
	// make calls to drone to physically move it
	if (quad = upperLeft) 
		move up by (moveY)
		move left by (moveX)
	else if (quad is upper Right)
		move up (moveY)
		move right (moveX)
	else if (quad lowerLeft)
		move down (moveY)
		move Left (moveX)
	else if (quad lowerRight)
		move down (moveY)
		move right (moveX)
	
	lower drone to (altitude * zoomRatio)

	if (altitude < threshold)
		call landing();
	else
		start();
	//note: can also recursively call this method with updated parameters, but this
	// will be implemented once we begin error checking/ ways to send
	
}

// helper to find quadrant
String findQuadrant(Double QRx, Double QRy, Double imgW, Double imgH) {
	StringBuffer quad = “”;
	if (QRy > imgH/2) 
		quad.add(“lower”);
	else quad.add(“upper”);
	if (QRx > imgW/2)
		quad.add(“right”);
	else quad.add(“left”);

	return quad.toString();
}

landing() {
	// ideally when reach ~5 ft threshold will be directly 
	// over QR code, make drone land directly down
}
